
















<!DOCTYPE html>
<html lang='en'><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <link rel="shortcut icon" href='//localhost:1313/favicon.ico' type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title> - Hori</title>

    

    

    
    <meta name="author" content="Ivan Porta" />
    

    

    <link rel="stylesheet" href="/style.css" integrity="">





    
    <script>
        if (!('theme' in localStorage)) {
            localStorage.theme = 'light';
        }

        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.setAttribute("data-theme", "dark");
        } else {
            document.documentElement.setAttribute("data-theme", "light");
        }
    </script>
<script defer src="/js/header.js" integrity=""></script>



    <script defer src="/js/zooming.js" integrity=""></script>







    
        
        
            <script defer src="/js/builtin-copy.js" integrity=""></script>
        
    



    
    
    
    <script defer src="/js/search-en.js" integrity=""></script>




<link rel="stylesheet" href="//localhost:1313/user.css">

    
</head>
<body><header>
    <div id="header_left">
        <div id="sidebar_btn">
            <input type="checkbox" id="sidebar_btn_input" class="hidden" />
            <label id="sidebar_btn_label" for="sidebar_btn_input">
                <svg id="menu_icon" width="26px" height="26px" viewBox="0 0 24 24">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="24" height="24" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>
</svg>

</svg>
            </label>
            <label id="sidebar_canvas_overlay_wrapper" for="sidebar_btn_input">
                <div id="sidebar_canvas_overlay"></div>
            </label>
            <div id="sidebar">
                <ul><li>
                            <a href="/control-plane/">Control Plane</a>
    <ul>
        

            
                <li>
                    
                        <span><a href="/control-plane/destination">Destination Controller</a></span>
                    
    <ul>
        

            
                <li>
                    
                        <a href="/control-plane/destination/server">Server</a>
                    
                </li>
            
        

            
                <li>
                    
                        <a href="/control-plane/destination/endpoints-watcher">Endpoints Watcher</a>
                    
                </li>
            
        

            
                <li>
                    
                        <a href="/control-plane/destination/federated-service-watcher">Federated Service Watcher</a>
                    
                </li>
            
        

            
                <li>
                    
                        <a href="/control-plane/destination/opaque-port-watcher">Opaque Port Watcher</a>
                    
                </li>
            
        

            
                <li>
                    
                        <a href="/control-plane/destination/profile-watcher">Profile Watcher</a>
                    
                </li>
            
        

            
                <li>
                    
                        <a href="/control-plane/destination/workload-watcher">Workload Watcher</a>
                    
                </li>
            
        

            
                <li>
                    
                        <a href="/control-plane/destination/external-workloads-controller">External Workloads Controller</a>
                    
                </li>
            
        
    </ul>
</li>
            
        

            
                <li>
                    
                        <a href="/control-plane/proxy-injector">Proxy-Injector Controller</a>
                    
                </li>
            
        
    </ul>
</li><li>
                            <a href="/data-plane/">Data Plane</a>
    <ul>
        

            
                <li>
                    
                        <a href="/data-plane/proxy-init">Proxy-Init</a>
                    
                </li>
            
        
    </ul>
</li><li>
                            <a href="/modules/">Modules</a>
    <ul>
        

            
                <li>
                    
                        <a href="/modules/certificates">Certificates</a>
                    
                </li>
            
        

            
                <li>
                    
                        <a href="/modules/timeouts">Timeouts</a>
                    
                </li>
            
        

            
                <li>
                    
                        <a href="/modules/cli">Linkerd CLI</a>
                    
                </li>
            
        
    </ul>
</li><li>
                            <a href="/changelog/">Changelog</a></li></ul>
            </div>
        </div>
    
        <div class="brand">
            <div>
                <a href="/">Hori</a>
            </div>
        </div>
    </div>

    <div class="toolbox">
        <div id="theme_tool">
            <svg id="dark_mode_btn" class="toolbox-btn" width="18px" height="18px" viewBox="0 0 24 24">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="24" height="24" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

</svg>
            <svg id="light_mode_btn" class="toolbox-btn" width="18px" height="18px" viewBox="0 0 24 24">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="24" height="24" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
</svg>

</svg>
        </div>

        
            <div id="search_tool">
                <svg id="search_btn" class="toolbox-btn" width="18px" height="18px" viewBox="0 0 24 24">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="24" height="24" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line>
</svg>

</svg><div id="search_menu_wrapper" class="hidden">
    <div id="search_menu">
        <div id="search_menu_toolbar">
            <div id="search_menu_input_wrapper">
                <input id="search_menu_input" type="text" placeholder='Search Posts'>
            </div>
            <div id="search_menu_close_btn">
                <svg width="18px" height="18px" viewBox="0 0 24 24">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="24" height="24" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line>
</svg>

</svg>
            </div>
        </div>
        <div id="search_menu_results">
        </div>
    </div>
</div>
</div>
        

        
            <div id="translation_tool" class="dropdown-wrapper pure-menu pure-menu-horizontal toolbox-btn" onclick="void(0)">
                <ul class="pure-menu-list">
                    <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
                        <div class="dropdown-btn pure-menu-link">
                            <svg width="18px" height="18px" viewBox="0 0 24 24">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="24" height="24" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
</svg>

</svg>
                            <span class="dropdown-desc">English</span>
                        </div>
                        <ul class="pure-menu-children">
                            
                            <li class="pure-menu-item">
                                <a href="//localhost:1313/" class="pure-menu-link">English</a>
                            </li>
                            
                            <li class="pure-menu-item">
                                <a href="//localhost:1313/ko/" class="pure-menu-link">한국어</a>
                            </li>
                            
                        </ul>
                    </li>
                </ul>
            </div>
        
    </div>
</header>
<nav id="navbar" class="pure-menu">
    <ul class="pure-menu-list"><li class="navbar-item navbar-dropdown pure-menu-item pure-menu-has-children pure-menu-allow-hover insection">
                    
                        <a href="/control-plane/" class="pure-menu-link">Control Plane</a>
                    
                    <ul class="pure-menu-children">

    
        <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
            
                <a href="/control-plane/destination" class="pure-menu-link">Destination Controller</a>
            
            <ul class="pure-menu-children">

    
        <li class="pure-menu-item">
            
                <a href="/control-plane/destination/server" class="pure-menu-link">Server</a>
            
        </li>
    


    
        <li class="pure-menu-item">
            
                <a href="/control-plane/destination/endpoints-watcher" class="pure-menu-link">Endpoints Watcher</a>
            
        </li>
    


    
        <li class="pure-menu-item">
            
                <a href="/control-plane/destination/federated-service-watcher" class="pure-menu-link">Federated Service Watcher</a>
            
        </li>
    


    
        <li class="pure-menu-item">
            
                <a href="/control-plane/destination/opaque-port-watcher" class="pure-menu-link">Opaque Port Watcher</a>
            
        </li>
    


    
        <li class="pure-menu-item">
            
                <a href="/control-plane/destination/profile-watcher" class="pure-menu-link">Profile Watcher</a>
            
        </li>
    


    
        <li class="pure-menu-item">
            
                <a href="/control-plane/destination/workload-watcher" class="pure-menu-link">Workload Watcher</a>
            
        </li>
    


    
        <li class="pure-menu-item">
            
                <a href="/control-plane/destination/external-workloads-controller" class="pure-menu-link">External Workloads Controller</a>
            
        </li>
    

</ul>
        </li>
    


    
        <li class="pure-menu-item">
            
                <a href="/control-plane/proxy-injector" class="pure-menu-link">Proxy-Injector Controller</a>
            
        </li>
    

</ul>
                </li><li class="navbar-item navbar-dropdown pure-menu-item pure-menu-has-children pure-menu-allow-hover ">
                    
                        <a href="/data-plane/" class="pure-menu-link">Data Plane</a>
                    
                    <ul class="pure-menu-children">

    
        <li class="pure-menu-item">
            
                <a href="/data-plane/proxy-init" class="pure-menu-link">Proxy-Init</a>
            
        </li>
    

</ul>
                </li><li class="navbar-item navbar-dropdown pure-menu-item pure-menu-has-children pure-menu-allow-hover ">
                    
                        <a href="/modules/" class="pure-menu-link">Modules</a>
                    
                    <ul class="pure-menu-children">

    
        <li class="pure-menu-item">
            
                <a href="/modules/certificates" class="pure-menu-link">Certificates</a>
            
        </li>
    


    
        <li class="pure-menu-item">
            
                <a href="/modules/timeouts" class="pure-menu-link">Timeouts</a>
            
        </li>
    


    
        <li class="pure-menu-item">
            
                <a href="/modules/cli" class="pure-menu-link">Linkerd CLI</a>
            
        </li>
    

</ul>
                </li><li class="navbar-item pure-menu-item ">
                    
                        <a href="/changelog/" class="pure-menu-link">Changelog</a>
                    
                </li></ul>
</nav>
<main>
            <div id="content" class="content-margin">
                


    <div class="content-margin">



<article class="line-numbers">
    
    
    
<h2 id="6-external-workloads-controller" class="header-anchor-wrapper">6. External Workloads Controller
  <a href="#6-external-workloads-controller" class="header-anchor-link">
    <svg width="16px" height="16px" viewBox="0 0 24 24">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="24" height="24" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</svg>
  </a>
</h2>

<p>Linkerd’s destination subsystem manages <code>ExternalWorkload</code> resources to represent workloads running outside the cluster. Unlike normal Pods, these workloads are not native Kubernetes objects; their IPs live in the <code>ExternalWorkload.spec.workloadIPs</code> field.</p>
<pre><code>kubectl get externalworkload -n simple-app   external-simple-app-v1-0e340584 -o yaml
apiVersion: workload.linkerd.io/v1beta1
kind: ExternalWorkload
metadata:
  name: external-simple-app-v1-0e340584
  namespace: simple-app
  ...
spec:
  meshTLS:
    identity: spiffe://root.linkerd.cluster.local/proxy-harness
    serverName: external-simple-app-v1-0e340584.simple-app.external.identity.linkerd.cluster.local
  ports:
  - name: http
    port: 80
    protocol: TCP
  workloadIPs:
  - ip: 172.20.0.8
...
</code></pre>
<p>When an <code>ExternalWorkload</code> is created, updated, or deleted, Linkerd’s controller sets up informers to catch those events and invoke the related function in the handler.</p>
<pre><code>func (ec *EndpointsController) addHandlers() error {
	...
	ec.ewHandle, err = ec.k8sAPI.ExtWorkload().Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc:    ec.onAddExternalWorkload,
		DeleteFunc: ec.onDeleteExternalWorkload,
		UpdateFunc: ec.onUpdateExternalWorkload,
	})
	if err != nil {
		return err
	}
	return nil
}
</code></pre>
<p>To decide which Services should include a given <code>ExternalWorkload</code>, the controller uses a label‐selector match to create a list of <code>&lt;namespace&gt;/&lt;service-name&gt;</code> so that it will know exactly which Services need to be re‐synced.</p>
<pre><code>func (ec *EndpointsController) getExternalWorkloadSvcMembership(workload *ewv1beta1.ExternalWorkload) (sets.Set[string], error) {
	keys := sets.Set[string]{}
	services, err := ec.k8sAPI.Svc().Lister().Services(workload.Namespace).List(labels.Everything())
	if err != nil {
		return keys, err
	}
	for _, svc := range services {
		if svc.Spec.Selector == nil {
			continue
		}
		key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(svc)
		if err != nil {
			return sets.Set[string]{}, err
		}
		if labels.ValidatedSetSelector(svc.Spec.Selector).Matches(labels.Set(workload.Labels)) {
			keys.Insert(key)
		}
	}
	return keys, nil
}
</code></pre>
<p>When an <code>ExternalWorkload</code> is updated, it re‐evaluate both its IPs and its labels. Only if something actually changed do it will re‐enqueue the affected Services.</p>
<pre><code>func (ec *EndpointsController) getServicesToUpdateOnExternalWorkloadChange(old, cur interface{}) sets.Set[string] {
	newEw, newEwOk := cur.(*ewv1beta1.ExternalWorkload)
	oldEw, oldEwOk := old.(*ewv1beta1.ExternalWorkload)
	if !oldEwOk {
		ec.log.Errorf(&quot;Expected (cur) to be an EndpointSlice in getServicesToUpdateOnExternalWorkloadChange(), got type: %T&quot;, cur)
		return sets.Set[string]{}
	}
	if !newEwOk {
		ec.log.Errorf(&quot;Expected (old) to be an EndpointSlice in getServicesToUpdateOnExternalWorkloadChange(), got type: %T&quot;, old)
		return sets.Set[string]{}
	}
	if newEw.ResourceVersion == oldEw.ResourceVersion {
		return sets.Set[string]{}
	}
	ewChanged, labelsChanged := ewEndpointsChanged(oldEw, newEw)
	if !ewChanged &amp;&amp; !labelsChanged {
		ec.log.Errorf(&quot;skipping update; nothing has changed between old rv %s and new rv %s&quot;, oldEw.ResourceVersion, newEw.ResourceVersion)
		return sets.Set[string]{}
	}
	services, err := ec.getExternalWorkloadSvcMembership(newEw)
	if err != nil {
		ec.log.Errorf(&quot;unable to get pod %s/%s's service memberships: %v&quot;, newEw.Namespace, newEw.Name, err)
		return sets.Set[string]{}
	}
	if labelsChanged {
		oldServices, err := ec.getExternalWorkloadSvcMembership(oldEw)
		if err != nil {
			ec.log.Errorf(&quot;unable to get pod %s/%s's service memberships: %v&quot;, oldEw.Namespace, oldEw.Name, err)
		}
		services = determineNeededServiceUpdates(oldServices, services, ewChanged)
	}
	return services
}
</code></pre>
<p>Once Services are enqueued, a background worker handles them one at a time.</p>
<pre><code>func (ec *EndpointsController) processQueue() {
	for {
		key, quit := ec.queue.Get()
		if quit {
			ec.log.Trace(&quot;queue received shutdown signal&quot;)
			return
		}
		err := ec.syncService(key)
		ec.handleError(err, key)
		ec.queue.Done(key)
	}
}
</code></pre>
<p>The <code>syncService</code> method ensures the set of EndpointSlice objects for a Service matches exactly the IPs from its corresponding ExternalWorkload CRs. It will consider only Services with a Type different than <code>ExternalName</code>.</p>
<pre><code>func (ec *EndpointsController) syncService(update string) error {
	namespace, name, err := cache.SplitMetaNamespaceKey(update)
	if err != nil {
		return err
	}
	svc, err := ec.k8sAPI.Svc().Lister().Services(namespace).Get(name)
	if err != nil {
		if !kerrors.IsNotFound(err) {
			return err
		}
		ec.reconciler.endpointTracker.DeleteService(namespace, name)
		return nil
	}
	if svc.Spec.Type == corev1.ServiceTypeExternalName {
		return nil
	}
	if svc.Spec.Selector == nil {
		return nil
	}
	ewSelector := labels.Set(svc.Spec.Selector).AsSelectorPreValidated()
	ews, err := ec.k8sAPI.ExtWorkload().Lister().List(ewSelector)
	if err != nil {
		return err
	}
	esSelector := labels.Set(map[string]string{
		discoveryv1.LabelServiceName: svc.Name,
		discoveryv1.LabelManagedBy:   managedBy,
	}).AsSelectorPreValidated()
	epSlices, err := ec.k8sAPI.ES().Lister().List(esSelector)
	if err != nil {
		return err
	}
	epSlices = dropEndpointSlicesPendingDeletion(epSlices)
	if ec.reconciler.endpointTracker.StaleSlices(svc, epSlices) {
		ec.log.Warnf(&quot;detected EndpointSlice informer cache is out of date when processing %s&quot;, update)
		return errors.New(&quot;EndpointSlice informer cache is out of date&quot;)
	}
	err = ec.reconciler.reconcile(svc, ews, epSlices)
	if err != nil {
		return err
	}
	return nil
}
</code></pre>
<p>Fianlly, it will delegates the heavy lifting to the <code>reconcile</code> method. The goal of this method is to produce exactly the right set of <code>EndpointSlice</code> objects so that each Service’s external IPs (from <code>ExternalWorkload</code>) are reflected. It will immediately deletes any slices that advertise an <code>AddressType</code> the Service no longer supports, create three lists with the slices to Create, Update, or Delete.</p>
<pre><code>func (r *endpointsReconciler) reconcile(svc *corev1.Service, ews []*ewv1beta1.ExternalWorkload, existingSlices []*discoveryv1.EndpointSlice) error {
	toDelete := []*discoveryv1.EndpointSlice{}
	slicesByAddrType := make(map[discoveryv1.AddressType][]*discoveryv1.EndpointSlice)
	errs := []error{}
	supportedAddrTypes := getSupportedAddressTypes(svc)
	for _, slice := range existingSlices {
		if _, supported := supportedAddrTypes[slice.AddressType]; !supported {
			toDelete = append(toDelete, slice)
			continue
		}
		if _, ok := slicesByAddrType[slice.AddressType]; !ok {
			slicesByAddrType[slice.AddressType] = []*discoveryv1.EndpointSlice{}
		}
		slicesByAddrType[slice.AddressType] = append(slicesByAddrType[slice.AddressType], slice)
	}
	for addrType := range supportedAddrTypes {
		existingSlices := slicesByAddrType[addrType]
		err := r.reconcileByAddressType(svc, ews, existingSlices, addrType)
		if err != nil {
			errs = append(errs, err)
		}
	}
	for _, slice := range toDelete {
		err := r.k8sAPI.Client.DiscoveryV1().EndpointSlices(svc.Namespace).Delete(context.TODO(), slice.Name, metav1.DeleteOptions{})
		if err != nil {
			errs = append(errs, err)
		}
	}
	return utilerrors.NewAggregate(errs)
}
</code></pre>
<p>Once we know exactly which slices need to be created, updated, or deleted, we push those changes to Kubernetes.</p>
<pre><code>func (r *endpointsReconciler) finalize(svc *corev1.Service, slicesToCreate, slicesToUpdate, slicesToDelete []*discoveryv1.EndpointSlice) error {
	for i := 0; i &lt; len(slicesToDelete); {
		if len(slicesToCreate) == 0 {
			break
		}
		sliceToDelete := slicesToDelete[i]
		slice := slicesToCreate[len(slicesToCreate)-1]
		if sliceToDelete.AddressType == slice.AddressType &amp;&amp; ownedBy(sliceToDelete, svc) {
			slice.Name = sliceToDelete.Name
			slicesToCreate = slicesToCreate[:len(slicesToCreate)-1]
			slicesToUpdate = append(slicesToUpdate, slice)
			slicesToDelete = append(slicesToDelete[:i], slicesToDelete[i+1:]...)
		} else {
			i++
		}
	}
	r.log.Debugf(&quot;reconciliation result for %s/%s: %d to add, %d to update, %d to remove&quot;, svc.Namespace, svc.Name, len(slicesToCreate), len(slicesToUpdate), len(slicesToDelete))
	if svc.DeletionTimestamp == nil {
		for _, slice := range slicesToCreate {
			r.log.Tracef(&quot;starting create: %s/%s&quot;, slice.Namespace, slice.Name)
			createdSlice, err := r.k8sAPI.Client.DiscoveryV1().EndpointSlices(svc.Namespace).Create(context.TODO(), slice, metav1.CreateOptions{})
			if err != nil {
				if errors.HasStatusCause(err, corev1.NamespaceTerminatingCause) {
					return nil
				}
				return err
			}
			r.endpointTracker.Update(createdSlice)
			r.log.Tracef(&quot;finished creating: %s/%s&quot;, createdSlice.Namespace, createdSlice.Name)
		}
	}
	for _, slice := range slicesToUpdate {
		r.log.Tracef(&quot;starting update: %s/%s&quot;, slice.Namespace, slice.Name)
		updatedSlice, err := r.k8sAPI.Client.DiscoveryV1().EndpointSlices(svc.Namespace).Update(context.TODO(), slice, metav1.UpdateOptions{})
		if err != nil {
			return err
		}
		r.endpointTracker.Update(updatedSlice)
		r.log.Tracef(&quot;finished updating: %s/%s&quot;, updatedSlice.Namespace, updatedSlice.Name)
	}
	for _, slice := range slicesToDelete {
		r.log.Tracef(&quot;starting delete: %s/%s&quot;, slice.Namespace, slice.Name)
		err := r.k8sAPI.Client.DiscoveryV1().EndpointSlices(svc.Namespace).Delete(context.TODO(), slice.Name, metav1.DeleteOptions{})
		if err != nil {
			return err
		}
		r.endpointTracker.ExpectDeletion(slice)
		r.log.Tracef(&quot;finished deleting: %s/%s&quot;, slice.Namespace, slice.Name)
	}
	return nil
}
</code></pre>
<p>Because multiple <code>destination</code> controller replicas may run, Linekrd use a leader election pattern to ensure only one instance writes <code>EndpointSlice</code> objects at a time. It uses a Kubernetes <code>Lease</code> object to coordinate leadership with the following configuration.</p>
<pre><code>ec.lec = leaderelection.LeaderElectionConfig{
    Lock: &amp;resourcelock.LeaseLock{
        LeaseMeta: metav1.ObjectMeta{
            Name:      &quot;linkerd-destination-endpoint-write&quot;,
            Namespace: controllerNs,
        },
        Client: k8sAPI.Client.CoordinationV1(),
        LockConfig: resourcelock.ResourceLockConfig{
            Identity: hostname,  // unique ID per instance
        },
    },
    LeaseDuration: 30 * time.Second,
    RenewDeadline: 10 * time.Second,
    RetryPeriod:   2 * time.Second,
    Callbacks: leaderelection.LeaderCallbacks{
        OnStartedLeading: ec.addHandlers,
        OnStoppedLeading: ec.removeHandlers,
    },
}
</code></pre>
<p>As long as the leader continues to renew, it keeps reconciling ExternalWorkload changes. If it fails, another replica becomes leader and resumes write operations. You will be able to see an output with the periodic renewals.</p>
<pre><code>time=&quot;2025-05-19T08:53:23Z&quot; level=info msg=&quot;PUT https://10.247.0.1:443/apis/coordination.k8s.io/v1/namespaces/linkerd/leases/linkerd-destination-endpoint-write 200 OK in 2 milliseconds&quot;
...
time=&quot;2025-05-19T08:53:25Z&quot; level=info msg=&quot;PUT https://10.247.0.1:443/apis/coordination.k8s.io/v1/namespaces/linkerd/leases/linkerd-destination-endpoint-write 200 OK in 6 milliseconds&quot;
</code></pre>

</article>
</div>


                
                    
                

                
            </div>
        </main>
<footer>
    <article>Copyright © 2025</article>
</footer>

</body>
</html>
